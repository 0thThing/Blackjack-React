[{"C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\index.js":"1","C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\App.js":"2","C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\reportWebVitals.js":"3","C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\components\\Game.js":"4","C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\components\\Dealer.js":"5","C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\components\\Message.js":"6","C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\components\\Player.js":"7","C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\components\\StatsArea.js":"8","C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\components\\BettingArea.js":"9"},{"size":500,"mtime":499162500000,"results":"10","hashOfConfig":"11"},{"size":849,"mtime":1611020838622,"results":"12","hashOfConfig":"11"},{"size":362,"mtime":499162500000,"results":"13","hashOfConfig":"11"},{"size":24841,"mtime":1611701597534,"results":"14","hashOfConfig":"11"},{"size":814,"mtime":1611654885437,"results":"15","hashOfConfig":"11"},{"size":280,"mtime":1610492818697,"results":"16","hashOfConfig":"11"},{"size":1029,"mtime":1611654900820,"results":"17","hashOfConfig":"11"},{"size":547,"mtime":1610617010049,"results":"18","hashOfConfig":"11"},{"size":1090,"mtime":1610666716708,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"n21m9d",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"22"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\index.js",[],["41","42"],"C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\App.js",[],"C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\reportWebVitals.js",[],"C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\components\\Game.js",["43"],"import React from 'react';\r\nimport Dealer from './Dealer'\r\nimport Player from './Player'\r\nimport Message from './Message'\r\nimport StatsArea from \"./StatsArea\";\r\nimport BettingArea from \"./BettingArea\";\r\n\r\n//Made by Jordan Lawrence\r\n//not sure how error proof this is, maybe I should have a fetch and .catch in case something goes wrong\r\n//adding key prop fixed the Player constructor not being called when it was passed new props\r\n//realized <li> and <ul> have padding you have to explicitly override in css\r\n//note: highLowCount state variable is using the high-low card counting strategy that many people may not be familiar with\r\n//This is deployed with firebase at https://blackjack-65c0d.web.app/\r\n//todo not sure why handleBet is passed to player and I think it has no purpose\r\n//todo all the hands should be in the same array of arrays, since implementing split made me have an array of arrays the player hand should be in there to\r\n//todo realized just now that 3 to 2 payout has not been implemented for blackjack, as well as insurance\r\nclass Game extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            remainingHands: 0, //might not actually need this since split hands.length might work as a counter\r\n            splitHands: [], //This should be a list of lists. where each list is a split hand, and within that list is a list of cards for that hand\r\n            splitBets: [], //parallel list of bets for the split hands\r\n            dealerCards: [],\r\n            dealerTotal: 0,\r\n            playerCards: [],\r\n            playerTotal: 0,\r\n            deckID: \"\",\r\n            cardsRemaining: 0,\r\n            canDoubleDown: true,\r\n            canSplit: false,\r\n            isRoundOver: true,\r\n            isBettingPhase: true,\r\n            userWins: 0,\r\n            userLosses: 0,\r\n            userDraws: 0,\r\n            highLowCount: 0,\r\n            funds: 200,\r\n            currentBet: 0,\r\n            placedBet: 0,\r\n            totalBet: 0, //this is for keeping a running total of splitBet and any doubledowns, I could loop through splitBet but this seems like it might be more efficient\r\n            betAtRoundStart: 0, //I dont want to use this if I can avoid it, but this is just to keep track of the bet that should be added when a user splits\r\n            message: \"Welcome!\"\r\n\r\n        }\r\n        this.drawPlayerCard = this.drawPlayerCard.bind(this)\r\n        this.placeBet = this.placeBet.bind(this)\r\n        this.handleBet = this.handleBet.bind(this)\r\n        this.resetBet = this.resetBet.bind(this)\r\n        this.drawStartingHands = this.drawStartingHands.bind(this)\r\n        this.handleHit = this.handleHit.bind(this)\r\n        this.handleStay = this.handleStay.bind(this)\r\n        this.totalHandValue = this.totalHandValue.bind(this)\r\n        this.shuffle = this.shuffle.bind(this)\r\n        this.shuffleAndDraw = this.shuffleAndDraw.bind(this) //think this can be deleted its only used in componentDidMount\r\n        this.findWinner = this.findWinner.bind(this)\r\n        this.drawCards = this.drawCards.bind(this)\r\n        this.handleDoubleDown = this.handleDoubleDown.bind(this)\r\n        this.handleSplit = this.handleSplit.bind(this)\r\n        this.clearHands = this.clearHands.bind(this)\r\n        this.checkForBust = this.checkForBust.bind(this)\r\n\r\n        this.rotateSplitHand = this.rotateSplitHand.bind(this)\r\n        this.evaluateSplitHands = this.evaluateSplitHands.bind(this)\r\n    }\r\n\r\n    async handleHit(){\r\n        await this.drawPlayerCard()\r\n        this.checkForBust(this.state.playerTotal)\r\n    }\r\n    async drawPlayerCard(){\r\n        //draw a card and set the new state with hand and total\r\n        //callback to figure out if we have busted and if there are more hands to act on and handle all the situations\r\n        let card = await this.drawCards(1)\r\n        let new_card = card\r\n\r\n        this.setState(prevState => {\r\n            let newHandValue = this.totalHandValue([...prevState.playerCards, ...new_card])\r\n            console.log('maybe drawPlayer card is the one respoinsible: '+newHandValue)\r\n\r\n            return {\r\n                playerCards: [...prevState.playerCards, ...new_card],\r\n                playerTotal: newHandValue\r\n            }\r\n        })\r\n\r\n\r\n    }\r\n\r\n    checkForBust(total){\r\n        //if we bust check how many hand are left and return false, if we didnt bust do nothing and return true\r\n        let playerBusted = false\r\n        if (total > 21) {\r\n            playerBusted = true\r\n            if (this.state.remainingHands > 1) {\r\n                this.rotateSplitHand()\r\n                this.setState(prevState => {\r\n                    return {\r\n                        message: 'too many, hopefully the other hands work out better',\r\n                    }\r\n\r\n                })\r\n            }\r\n            else {\r\n\r\n                this.setState(prevState => {\r\n\r\n                    //here we just have to handle a regular bust\r\n                    return {\r\n                        isRoundOver: true,\r\n                        canDoubleDown: false,\r\n                        isBettingPhase: false,\r\n                        message: 'too many, play again?',\r\n                        funds: prevState.funds - prevState.placedBet\r\n                    }\r\n                },this.evaluateSplitHands(this.state.splitHands,this.state.splitBets)) //we have already taken care of the current player hand and bet so just the possible split hands must be passed in\r\n            }//EVAL SPLIT HANDS HERE\r\n        }\r\n        return playerBusted\r\n\r\n    }\r\n\r\n    evaluateSplitHands(splitHands, splitBets) {\r\n        if (splitHands.length === 0) {\r\n            //we have no split hands so return\r\n            return\r\n        }\r\n        else {\r\n            let dealerTotal = this.state.dealerTotal\r\n            let fundAdjustment = 0 //thought this would be easier since I do not want to call setState over and over if it can be avoided\r\n            for (let i = 0; i < splitHands.length; i++) {\r\n                let handValue = this.totalHandValue(splitHands[i])\r\n\r\n                if (handValue > 21) {\r\n                    fundAdjustment -= splitBets[i]\r\n                    console.log('the fund adjustment after loss is now: ',fundAdjustment)\r\n                    this.setState(prevState => {\r\n\r\n                        return {\r\n                            userLosses: prevState.userLosses + 1,\r\n\r\n                        }\r\n                    })\r\n                } else if (dealerTotal === handValue) {\r\n                    //no need to adjust funds since we drew the hand\r\n                    this.setState(prevState => {\r\n\r\n                        return {\r\n                            userDraws: prevState.userDraws + 1,\r\n\r\n                        }\r\n                    })\r\n                } else if ((dealerTotal > 21 && handValue <= 21) || (this.state.dealerTotal < handValue && handValue <= 21)) {\r\n                    fundAdjustment += splitBets[i]\r\n                    this.setState(prevState => {\r\n                        console.log('the fund adjustment after win is now: ',fundAdjustment)\r\n\r\n                        return {\r\n                            userWins: prevState.userWins + 1,\r\n                        }\r\n                    })\r\n                }\r\n                else{\r\n                    fundAdjustment -= splitBets[i]\r\n                    console.log('the fund adjustment after loss by default is now: ',fundAdjustment)\r\n                    this.setState(prevState => {\r\n\r\n                        return {\r\n                            userLosses: prevState.userLosses + 1,\r\n\r\n                        }\r\n                    })\r\n                }\r\n            }\r\n\r\n            this.setState(prevState => {\r\n                return{funds: prevState.funds + fundAdjustment}\r\n            })\r\n\r\n        }\r\n    }\r\n\r\n\r\n    rotateSplitHand(){\r\n        //this should just rotate the split hand and bet parralel arrays\r\n        this.setState(prevState =>\r\n        {\r\n            let newSplitHands = [...prevState.splitHands]\r\n            console.log('the newSplithands cariable in handleStay befoire player cardds', newSplitHands)\r\n            let newPlayerHand = newSplitHands.shift() //shift is like pop but from the other side, works great!\r\n            newSplitHands.push(prevState.playerCards)\r\n            let newPlayerTotal = this.totalHandValue(newPlayerHand)\r\n\r\n            let newSplitBets = [...prevState.splitBets]\r\n            let newPlayerBet = newSplitBets.shift()\r\n            newSplitBets.push(prevState.placedBet)\r\n\r\n\r\n            //WOW took so long to notice there is a diference between console.log('stuff' + var) and console.log('stuff', var)\r\n\r\n\r\n            return{\r\n                playerCards: newPlayerHand,\r\n                splitHands: newSplitHands,\r\n                playerTotal: newPlayerTotal,\r\n                remainingHands: prevState.remainingHands - 1,\r\n                splitBets: newSplitBets,\r\n                placedBet: newPlayerBet,\r\n\r\n\r\n            }\r\n        })\r\n    }\r\n\r\n    async handleStay() {//this is awesome and close but only swaps front and back ion the array and we want whole aray to shift\r\n        // draw one card for dealer no matter what\r\n        if(this.state.remainingHands > 1)\r\n        {\r\n            //if we have split hands then this should just stay on hands until there are no hands to act on then draw dealer\r\n\r\n            this.rotateSplitHand()\r\n\r\n\r\n            return\r\n\r\n        }\r\n\r\n        let card = await this.drawCards(1)\r\n\r\n        let dealerHand = [...card, ...this.state.dealerCards]\r\n\r\n\r\n        while (this.totalHandValue(dealerHand) < 17) //drawing dealer to at least 17\r\n        {\r\n\r\n            let card = await this.drawCards(1)\r\n            dealerHand.push(...card)\r\n\r\n        }\r\n\r\n        this.setState(prevState => {\r\n                let newHandValue = this.totalHandValue([...dealerHand])\r\n                return {\r\n                    dealerCards: dealerHand,\r\n                    dealerTotal: newHandValue,\r\n                    isRoundOver: true,\r\n                    canDoubleDown: false,\r\n\r\n                }\r\n            }\r\n        )\r\n        console.log('befoer it goes to find winner player total was: '+this.state.playerTotal)\r\n        this.findWinner(this.state.playerTotal, this.state.dealerTotal)\r\n\r\n        this.evaluateSplitHands(this.state.splitHands,this.state.splitBets)\r\n    }\r\n\r\n\r\n\r\n    async drawCards(amount) {\r\n        if(this.state.cardsRemaining < 4){//4 seems arbitrary but since drawStartingHands() draws three cards leaving it at 1 will likely cause an error. havent tried it though\r\n            await this.shuffle()\r\n        }\r\n\r\n        let hiLowValue = 0  //the variable containing the value of the card in the hi-low counting system\r\n        let cardList = []\r\n        const url = 'https://deckofcardsapi.com/api/deck/' + this.state.deckID + '/draw/?count=' + amount\r\n        const response = await fetch(url)\r\n        let data = await response.json()\r\n        for (let i = 0; i < amount; i++) {\r\n\r\n            let card = {\r\n                image: data.cards[i].images,\r\n                value: data.cards[i].value,\r\n                suit: data.cards[i].suit,\r\n                code: data.cards[i].code\r\n            }\r\n            if (card.value === \"KING\" || card.value === \"QUEEN\" || card.value === \"JACK\" || card.value === \"ACE\" || card.value ===\"10\") {\r\n                hiLowValue += -1\r\n            }\r\n            if (card.value === \"2\" || card.value === \"3\" || card.value === \"4\" || card.value === \"5\" || card.value === \"6\") {\r\n                hiLowValue += 1\r\n            }\r\n            cardList.push(card)\r\n        }\r\n\r\n        this.setState(prevState => {\r\n            return {\r\n                highLowCount: prevState.highLowCount + hiLowValue,\r\n                cardsRemaining: data.remaining\r\n            }\r\n        })\r\n        return cardList;\r\n\r\n\r\n    }\r\n\r\n    placeBet (){\r\n        if(!this.state.isRoundOver)\r\n        {\r\n            this.setState({\r\n                message:'you can not place a bet during the round, no cheating!',\r\n                currentBet: 0\r\n            })\r\n        }\r\n        else if(this.state.funds < this.state.currentBet)\r\n        {\r\n            this.setState({\r\n                message:'you dont have the money for that!',\r\n                currentBet: 0\r\n            })\r\n\r\n        }\r\n        else\r\n        {\r\n            this.setState({\r\n                placedBet: this.state.currentBet,\r\n                totalBet: this.state.currentBet,\r\n                currentBet: 0 //reset the current bet since its been placed\r\n            })\r\n        }\r\n    }\r\n\r\n\r\n    handleBet (event){\r\n        //event.currentTarget.value somehow does not work here and I am unsure why\r\n\r\n        let value = event.currentTarget.getAttribute('value')\r\n        console.log('the amount trying to be added is ', value)\r\n        this.setState(prevState => {\r\n            return {\r\n            currentBet: prevState.currentBet + Number(value)\r\n            }\r\n        })\r\n        console.log(this.state.currentBet)\r\n    }\r\n\r\n\r\n    resetBet(){\r\n        this.setState({placedBet: 0})\r\n    }\r\n\r\n    findWinner (playerTotal, dealerTotal){\r\n        console.log('player total is: '+playerTotal+' dealer total: '+dealerTotal)\r\n        if (dealerTotal === playerTotal) {\r\n            this.setState(prevState => {\r\n                console.log('prevstate.placed bet is', prevState.placedBet)\r\n\r\n                return {\r\n                    userDraws: prevState.userDraws + 1,\r\n                    message: \"its a draw\"\r\n\r\n                }\r\n            })\r\n        }\r\n        else if ((this.state.dealerTotal > 21 && this.state.playerTotal <= 21) || (this.state.dealerTotal < this.state.playerTotal && this.state.playerTotal < 22))\r\n        {\r\n                this.setState(prevState => {\r\n\r\n                    return {\r\n                        userWins: prevState.userWins + 1,\r\n                        funds: prevState.funds + prevState.placedBet,\r\n                        message: 'you won!'\r\n                    }\r\n                })\r\n            }\r\n        else if (this.state.playerTotal > 21)// these last two share the same outcome and can be combined I think\r\n        {\r\n            this.setState(prevState => {\r\n\r\n                return {\r\n                    userLosses: prevState.userLosses + 1,\r\n                    funds: prevState.funds - prevState.placedBet,\r\n                    message: 'you busted'\r\n                }\r\n            })\r\n        }\r\n        else\r\n        {\r\n            this.setState(prevState => {\r\n\r\n                return {\r\n                    userLosses: prevState.userLosses + 1,\r\n                    funds: prevState.funds - prevState.placedBet,\r\n                    message: 'you lost'\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n\r\n    clearHands () {\r\n        this.setState({\r\n            playerCards: [],\r\n            dealerCards: [],\r\n            playerTotal: 0,\r\n            dealerTotal: 0,\r\n            isBettingPhase: true,\r\n            splitHands: [],\r\n            splitBets: [],\r\n            totalBet: 0,\r\n            message: 'place your bet by clicking the poker chips then the button beside them!'\r\n        })\r\n    }\r\n\r\n    async shuffle(){\r\n        const response = await fetch('https://deckofcardsapi.com/api/deck/new/shuffle/?deck_count=1')\r\n        let data = await response.json()\r\n        this.setState({\r\n            deckID: data.deck_id,\r\n            cardsRemaining: data.remaining,\r\n            highLowCount: 0 //count must be set to 0 since the cards are shuffled\r\n\r\n        })\r\n\r\n    }\r\n\r\n    async handleDoubleDown(){//we need to draw a card and then stay basically\r\n        // some weird math but since double down is only available for the first two cards this makes sense\r\n        if(this.state.totalBet + this.state.betAtRoundStart * 2 > this.state.funds)\r\n        {\r\n            alert('sorry you do not have enough money to double your bet')\r\n            return\r\n        }\r\n        this.setState(prevState => {\r\n            console.log('the placed bet was: ',prevState.placedBet)\r\n            return{\r\n                placedBet: prevState.placedBet * 2,\r\n                totalBet: prevState.totalBet + prevState.betAtRoundStart //just update the new totalBet\r\n            }\r\n        })\r\n        await this.drawPlayerCard()\r\n        let didBust = this.checkForBust(this.state.playerTotal)\r\n        if(!didBust){\r\n            await this.handleStay()\r\n        }\r\n       //the one problem was that handleHit would end the hand if it busts and rotate the hand then when handleStay is called its like the next hand is automatically played\r\n            //***FIXED\r\n    }\r\n\r\n\r\n    async handleSplit(){\r\n        //we check if split is possible then if it is we draw the cards from the deck and update the hands\r\n\r\n\r\n        let newTotalBet = this.state.totalBet + this.state.betAtRoundStart\r\n        if(newTotalBet > this.state.funds)\r\n        {\r\n            alert('you can not split, you have: '+this.state.funds+'$ but your total bet would be: '+newTotalBet)\r\n            return //just get out of handleSplit since its not possible\r\n        }\r\n\r\n        let cards = await this.drawCards(2)//we draw cards now since we know user has the funds\r\n        console.log(cards)\r\n\r\n        this.setState(prevState => {\r\n            console.log('player has these split hands ', [[prevState.playerCards[1], cards[1]], ...prevState.splitHands])\r\n            let newPlayerTotal = this.totalHandValue([prevState.playerCards[0], cards[0]])\r\n\r\n\r\n            //new part here\r\n\r\n\r\n\r\n                return {\r\n                    playerCards: [prevState.playerCards[0], cards[0]],\r\n                    splitHands: [[prevState.playerCards[1], cards[1]], ...prevState.splitHands],//hopefully this is a list of lists\r\n                    splitBets: [...prevState.splitBets, prevState.betAtRoundStart],\r\n                    totalBet: prevState.totalBet + prevState.betAtRoundStart,\r\n                    playerTotal: newPlayerTotal,\r\n                    remainingHands: prevState.remainingHands + 1,\r\n                    canSplit: prevState.playerCards[0].value === cards[0].value//checking if we can still split again, still need to make sure the other hand can or cant split though\r\n                }\r\n\r\n        }, () => {\r\n            console.log('player cards are now: ',this.state.playerCards)\r\n            console.log('the other hand is: ',this.state.splitHands)\r\n        })\r\n    }\r\n\r\n    async shuffleAndDraw() { //actually made for the reshuffle button since both these need to be ran after reshuffle is clicked\r\n            // or else the deck is shuffled and there are no cards and no way to draw a starting hand\r\n        await this.shuffle()\r\n        await this.drawStartingHands()\r\n    }\r\n\r\n    async componentDidMount() {\r\n        //when the component mounts we start a new deck(we used to draw a hand as well but since you can not bet once the hand is dealt I removed it\r\n        await this.shuffle()\r\n    }\r\n\r\n    async drawStartingHands(){\r\n        if(this.state.placedBet > this.state.funds) //we have a check against this in placeBet, one thing it does not cover though is losing money until you have a placed bet higher than your funds, that case is what this is for\r\n        {\r\n            alert('your bet is too high! you have to lower your bet to be below the amount of money')\r\n            return;\r\n        }\r\n        let cards = await this.drawCards(3)\r\n        let newPlayerCards = [cards[0],cards[1]]\r\n        let playerCanSplit = false;\r\n        if(cards[0].value === cards[1].value) // maybe this check can be moved to the render method?\r\n        {\r\n            playerCanSplit = true;\r\n        }\r\n\r\n        let startPlayerValue = this.totalHandValue(newPlayerCards)\r\n\r\n        let newDealerCard = [cards[2]]\r\n        //list containing 1 is strange but it allows the totalHandValue function to access the .length property\r\n        let startDealerValue = this.totalHandValue(newDealerCard)\r\n\r\n\r\n        this.setState(prevState => {\r\n\r\n            return {\r\n                dealerCards: [...newDealerCard],\r\n                playerCards: [...newPlayerCards],\r\n                playerTotal: startPlayerValue,\r\n                dealerTotal: startDealerValue,\r\n                isRoundOver: false,\r\n                isBettingPhase: false,\r\n                canSplit: playerCanSplit,\r\n                canDoubleDown: true,\r\n                message: 'Good Luck!',\r\n                remainingHands: 1, //dont like to hard code this but I plan to only call this once at the start since it deals the dealer as well\r\n                betAtRoundStart: prevState.placedBet\r\n            }\r\n        })\r\n\r\n    }\r\n\r\n\r\n    totalHandValue(hand) {\r\n\r\n        let card;\r\n        let sum=0;\r\n        let highAces = 0\r\n\r\n        for (let i =0;i<hand.length;i++) {\r\n            card = hand[i]\r\n            if (card.value === \"KING\" || card.value === \"QUEEN\" || card.value ===\"JACK\")\r\n            {\r\n                sum+=10\r\n            }\r\n            else if (card.value ===\"ACE\")\r\n            {\r\n                highAces += 1\r\n                sum += 11\r\n            }\r\n            else\r\n            {\r\n                sum = sum + Number(card.value)\r\n            }\r\n\r\n        }\r\n        while (sum > 21 && highAces > 0 )\r\n        {\r\n            sum -= 10\r\n            highAces--\r\n        }\r\n\r\n        return sum\r\n\r\n    }\r\n\r\n\r\n    render() {\r\n//the key for <Dealer> needs to be dealerTotal otherwise the value above dealer cards doesnt go away and new\r\n        //totals just keep being added, maybe its because that part of <dealer> doesnt need to change?\r\n\r\n        let splitPlayerHands = null\r\n        if (this.state.splitHands)//im not even sure I need to check this (I think the empty list evaluates to false anyways)\r\n        {\r\n\r\n            /*splitPlayerHands = this.state.splitHands.map((hand, index) => {\r\n                const bet = this.state.splitBets[index];\r\n                return <Player key={hand} cards={hand} total={this.totalHandValue(hand)} handleBet={this.handleBet} bet={bet}/>\r\n            });*/\r\n            splitPlayerHands = this.state.splitHands.map((hand, index) => {\r\n                console.log('the index is: ', index)\r\n                let splitBet = this.state.splitBets[index]\r\n                console.log(splitBet)\r\n                return <Player key={hand} cards={hand} total={this.totalHandValue(hand)} handleBet={this.handleBet} bet={splitBet}/>\r\n\r\n        })\r\n        }\r\n\r\n\r\n        console.log('split player hands: ',splitPlayerHands)\r\n        return (\r\n\r\n            <div >\r\n                <StatsArea key={this.state.highLowCount}\r\n\r\n                           wins={this.state.userWins}\r\n                           losses={this.state.userLosses}\r\n                           draws={this.state.userDraws}\r\n                           cardsRemaining={this.state.cardsRemaining}\r\n                           highLowCount={this.state.highLowCount}\r\n                           funds={this.state.funds}\r\n                />\r\n\r\n                <Dealer key={this.state.dealerTotal} cards={this.state.dealerCards} total={this.state.dealerTotal}/>\r\n                <Message  message={this.state.message}/>\r\n\r\n                {\r\n                    //this is messy logic making the buttons but basically there are three phases this button goes through, one is during the hand when it draws 1 card\r\n                    //the second is clearing the hand after the player has won or lost the hand. the third is after the hand is cleared and the player can bet\r\n                    //the player can still bet if the hand is over and not cleared though, which is intentional\r\n                }\r\n                {this.state.isRoundOver ? this.state.isBettingPhase ? <button className='button hand-button' onClick={this.drawStartingHands}>Deal Hands</button> : <button className='button hand-button' onClick={this.clearHands}>New Hand</button> : <button className='button hand-button' onClick={this.handleHit}>Draw</button>}\r\n                {!this.state.isRoundOver && <button className='button hand-button' onClick={this.handleStay}>Stay</button>}\r\n                <button className='button hand-button' onClick={this.handleSplit}>Split</button>\r\n                <Player key={this.state.playerCards} cards={this.state.playerCards} total={this.totalHandValue(this.state.playerCards)} handleBet={this.handleBet} bet={this.state.placedBet}/>\r\n                {splitPlayerHands}\r\n                <div style={{display: 'block', marginTop: '1%'}}>\r\n                    <BettingArea handleBet={this.handleBet} placeBet={this.placeBet} bet={this.state.currentBet} doubleDown={this.state.canDoubleDown} doubleBet={this.handleDoubleDown}/>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}\r\nexport default Game;\r\n\r\n","C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\components\\Dealer.js",[],"C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\components\\Message.js",[],["44","45"],"C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\components\\Player.js",[],"C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\components\\StatsArea.js",[],"C:\\Users\\Jordan\\WebstormProjects\\blackjack_with_react - Copy\\src\\components\\BettingArea.js",[],{"ruleId":"46","replacedBy":"47"},{"ruleId":"48","replacedBy":"49"},{"ruleId":"50","severity":1,"message":"51","line":155,"column":35,"nodeType":"52","messageId":"53","endLine":161,"endColumn":22},{"ruleId":"46","replacedBy":"54"},{"ruleId":"48","replacedBy":"55"},"no-native-reassign",["56"],"no-negated-in-lhs",["57"],"no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'fundAdjustment'.","ArrowFunctionExpression","unsafeRefs",["56"],["57"],"no-global-assign","no-unsafe-negation"]